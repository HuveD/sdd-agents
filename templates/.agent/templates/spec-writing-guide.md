---
title: 스펙 문서 작성 가이드
owner: Documentation Maintainer
status: Active
tags:
  - docs
  - specs
  - guidelines
---

# 스펙 문서 작성 가이드

본 가이드는 `docs/specs/` 하위에 작성되는 제품/기능 스펙 문서의 표준을 정의합니다.  
스펙 문서는 **코드를 전혀 보지 않은 외부 팀원/자문**도 읽고 이해할 수 있는 수준으로 작성되어야 합니다.

---

## 1. Spec의 정의

스펙(Specification)은 **프로젝트의 최종 보존 지식이자 기능 매뉴얼**입니다.  
다음이 모두 가능해야 합니다.

- 신규/외부 인원이 코드를 보지 않고도:
  - 시스템이 **무엇을**, **왜**, **어떤 규칙으로** 동작하는지 이해할 수 있다.
  - 주요 상태, 플로우, 예외 케이스, 비즈니스 정책을 파악할 수 있다.
- 스펙만 읽고도:
  - 설계 오류 가능성을 토론할 수 있다.
  - **프로세스 상의 병목**(조직/흐름 상의 병목, 코드 최적화와 무관)을 발견할 수 있다.
  - 기능이 실제로 어떤 “계약(Contract)”을 보장해야 하는지 합의할 수 있다.

### 1.1 Spec vs API 명세 vs 설계/운영 문서

역할을 명확히 분리합니다.

- **Spec (사양서)**:  
  - **WHAT & WHY**  
  - 시스템이 외부에서 보기에 어떤 행동을 하고, 어떤 규칙·정책을 따르는지  
  - 도메인 용어, 상태, 플로우, 예외, 비즈니스 규칙, 승인 기준

- **API 명세**:  
  - **HOW (인터페이스)**  
  - 엔드포인트, 요청/응답 스키마, 필드, 상태 코드, 에러 코드

- **설계/운영 문서**:  
  - **HOW (구현 & 운영)**  
  - 아키텍처, DB 스키마, 모듈/유즈케이스/함수 구조, 트랜잭션/락/Retry 정책, 로그/메트릭 설계, 성능 튜닝 전략

> **원칙**  
> Spec은 API 스키마나 구현·운영 세부사항을 포함하지 않습니다.  
> 필요 시 별도 문서로 **링크만** 제공합니다.

---

## 2. 핵심 원칙

### 2.1 최종 사양서만 작성

- **완결된 문서만 존재**
  - 스펙 문서는 “초안/진행 중 문서” 없이, 항상 최종 상태로만 관리합니다.
- **TODO 절대 금지**
  - `TODO`, `미정`, `TBD`, `추후 결정` 등의 표현을 사용하지 않습니다.
- **변경 이력 금지**
  - 버전, 날짜, 수정 내역, changelog, “최근 변경 사항” 섹션을 두지 않습니다.
  - 변경 이력은 Git/이슈 트래커로 관리합니다.
- **업데이트 = 전체 재작성**
  - 일부 문단만 덧붙이는 방식이 아니라, 문서 전체가 새로운 일관된 스냅샷이 되도록 고칩니다.

### 2.2 블랙박스 관점

- 스펙은 시스템을 **외부에서 관찰 가능한 행동** 기준으로 설명합니다.
  - “어떤 입력/상황에서 어떤 결과/상태가 되어야 하는가?”
- 다음과 같은 내용은 **직접 언급하지 않습니다.**
  - DB/테이블/컬럼 이름
  - 서비스/유즈케이스/함수/클래스 이름
  - 로그/메트릭 이름, 대시보드 구성
  - 타임아웃/백오프/Retry 횟수 등 수치

이 정보는 설계/운영 문서의 책임입니다.

### 2.3 도메인/비즈니스 규칙 중심

- 자료구조나 구현 방식이 아니라 **도메인 개념과 규칙**으로 설명합니다.
- 도메인 용어로 엔티티와 관계를 정의하고, 그 위에 상태·플로우·정책을 기술합니다.
- “이 테이블은 …”이 아니라, “이 시스템에는 ~~라는 개념이 있으며, 역할은 …이다”로 설명합니다.

---

## 3. 내용 원칙

### 3.1 도메인 모델 우선

- 문서 초반에 이 기능에 등장하는 **도메인 엔티티**와 **관계**를 정의합니다.
  - 예: “회원”, “구독”, “Trial 권한”, “접근 스냅샷” 등
- 각 엔티티는 다음 수준까지만 정의합니다.
  - 역할
  - 주요 속성(개념적; DB 컬럼명 아님)
  - 제약(유일성, 유효 범위, 관계 제약 등)

### 3.2 플로우 & 프로세스 관점

- 상위 플로우/상세 시나리오를 통해:
  - 어떤 단계들이 어떤 순서로 진행되는지
  - 각 단계의 **책임/입력/출력**이 무엇인지
  - 어떤 외부 시스템 또는 조직(팀/서비스)에 의존하는지
  를 드러냅니다.
- 리뷰어가 이 플로우만 보고도:
  - “어디가 업무 프로세스 상 병목이 될 수 있는지”
  - “어디서 설계 리스크가 생길 수 있는지”
  를 토론할 수 있어야 합니다.

### 3.3 상태와 정책을 통한 오동작 탐지 가능성

- 상태 정의 및 전이 규칙을 충분히 자세히 적어:
  - 불가능한 상태 조합,
  - 빠져 있는 전이,
  - 정책과 상충하는 상태
  를 문서만 보고도 찾을 수 있어야 합니다.
- 비즈니스 정책은 “누가 언제 무엇을 할 수 있는지/없는지”를 명확하게 제한합니다.

### 3.4 다이어그램 중심

- 복잡한 설명은 **Mermaid 다이어그램**으로 표현하고, 텍스트는 이를 보완하는 수준으로 작성합니다.
- 플로우/시퀀스/상태도만으로도 큰 그림이 잡히도록 구성합니다.

---

## 4. 경계 원칙 (Spec에 포함하지 않을 것)

다음 내용은 Spec에서 **절대 직접 기술하지 않습니다.**  
필요하면 설계/운영 문서를 링크로 참조합니다.

### 4.1 구현 세부사항

- DB 관련
  - 테이블/뷰/인덱스/컬럼 이름
  - 데이터베이스 스키마, 정규화/파티션 전략, REGIONAL BY ROW 등
- 코드 구조
  - 클래스/모듈/서비스/유즈케이스/함수 이름
  - 메서드 시그니처, 인터페이스 정의, 파일/폴더 경로
- 프레임워크/라이브러리 사용법
  - 특정 ORM, HTTP 클라이언트, 메시지 큐, 캐시 라이브러리 설정/옵션

### 4.2 API 세부사항

- 엔드포인트 URL, HTTP 메서드
- 요청/응답 Body/Query/Header 스키마
- 상태 코드, 에러 코드, 에러 Response 형식

### 4.3 운영/튜닝 세부사항

- 로그/메트릭 이름 및 필드 스키마
- 대시보드 구성, 알람 조건
- p95/p99 목표, 타임아웃/Retry/Backoff 값
- 장애 대응 절차, 온콜 정책

### 4.4 변경/버전 정보

- “2025-11-01 기준”, “v2에서 변경됨” 등 시점 언급
- 히스토리/변경점 목록

> **원칙**  
> Spec은 “최신 전체 스냅샷”입니다.  
> 변경 과정·버전 관리·세부 튜닝은 다른 문서와 도구(Git, Runbook 등)의 책임입니다.

---

## 5. 문서 구조 (권장 템플릿)

문서 상단 Front matter 예시:

```yaml
---
title: 문서 제목
tags:
  - domain
  - feature
---
````

주의: 문서는 부분 업데이트가 아닌 **완결된 사양** 형태(모든 섹션이 충족된 상태)여야 합니다.

### 필수 섹션 (8개)

#### 1. 목적/범위

* 이 기능이 **무엇**을 하고 **왜** 필요한지 간결하게 설명
* 포함 범위 / 제외 범위를 명시해 경계를 분명히 정의

  * 예: “모바일 클라이언트 UI는 범위에 포함되지 않음”

#### 2. 용어

* 문서 전체에서 사용하는 핵심 용어와 개념 정의

  * 도메인 특화 용어, 약어, 비즈니스 용어 모두 포함
* 동일 용어는 문서 전반에서 **일관된 의미**로 사용

#### 3. 도메인 모델

* 이 기능에 등장하는 **주요 엔티티**와 **관계**를 정의
* 각 엔티티에 대해 다음을 서술:

  * 역할 (이 개념이 시스템에서 하는 일)
  * 주요 속성 (개념적 수준, DB 컬럼명 금지)
  * 제약 조건 (유일성, 존재 조건, 관계 제약 등)
* 엔티티 간 관계(1:N, N:M, 포함/조합 등)를 텍스트 또는 간단 다이어그램으로 표현

#### 4. 목표/비목표

* **목표**:

  * 이 기능으로 달성하고자 하는 구체적인 결과
  * 사용자/시스템 관점에서 측정 가능하거나 확인 가능한 형태로 기술
* **비목표**:

  * 의도적으로 다루지 않는 범위
  * 기존 기능과의 구분, 기대하지 말아야 할 동작 명시

#### 5. 상위 플로우

* Mermaid 플로우차트로 전체 흐름 개요 시각화

  * 시작/종료 지점, 주요 단계, 분기/합류 포인트
* 각 단계에 대해 텍스트로 보완:

  * 단계의 **역할/입력/출력**
  * 외부 시스템/조직 의존 여부 (예: “결제사 승인 결과 필요”)
* 이 섹션만 읽어도:

  * 큰 그림,
  * 중요한 의사결정 지점,
  * 프로세스 상 병목 가능 지점
    을 파악할 수 있어야 합니다.

#### 6. 상세 시나리오

* 주요 사용자 여정 또는 시스템 시나리오별 **Mermaid 시퀀스 다이어그램**

  * 예: “신규 가입 시 첫 결제 + Trial 부여”, “구독 갱신 실패”, “구독 해지 후 재가입”
* 각 시나리오에 대해:

  * 참여자(Actor) 정의 (사용자, 클라이언트, 백엔드 서비스, 외부 시스템 등)
  * 메시지/이벤트 흐름과 핵심 의사결정 표현
* **API 호출이 필요한 경우**:

  * 다이어그램 내에서 “결제 API 호출”, “구독 상태 조회”처럼 개념적으로만 표현
  * 구체적인 URL/파라미터/응답 형식은 API 명세 문서로 분리

#### 7. 상태 정의/전이

* Mermaid State Diagram으로 상태 모델 표현

  * 예: 구독 상태(Active/Grace/Expired/Cancelled 등), Trial 상태, Entitlement 상태 등
* 각 상태에 대해:

  * 상태의 의미
  * 해당 상태에서 허용/금지되는 행동
* 전이(Transition)에 대해:

  * 어떤 조건/이벤트에서 전이가 발생하는지
  * 허용되지 않는 전이(Forbidden transition)가 있다면 명시
* 이 섹션만 보고도:

  * “어떤 상태 조합이 말이 안 되는지”
  * “누락된 상태/전이가 있는지”
    를 검토할 수 있어야 합니다.

#### 8. 정책

* **비즈니스 규칙**

  * 가격/Trial/권한/사용량 등 도메인 규칙
  * 예: “동일 회원·동일 상품에 대해 활성 구독은 한 건만 허용”
* **권한/보안**

  * 누가/언제/어떤 리소스에 접근할 수 있는지
  * 인증/인가 관점의 정책 (실제 구현 방식은 설계 문서로 분리)
* **에러 처리 정책**

  * 사용자에게 노출되는 에러 유형과 메시지 레벨(예: 사용자 조치 가능 vs 불가)
  * 자동 복구되는 실패 vs 사용자의 재시도가 필요한 실패 구분
* **재시도/복구**

  * “재시도/복구가 있다”는 사실과 **의도**만 기술

    * 예: “외부 결제 시스템 일시 오류 시, 나중에 재시도되어 최종적으로 상태가 일관되도록 맞춰진다”
  * 구체적인 횟수/간격/알고리즘은 설계/운영 문서에서 다룸
* **성능/제약(개념 수준)**

  * 응답 시간/처리량 목표를 숫자 대신 **등급/우선순위**로 표현 가능

    * 예: “동기 응답이 필요한 API, 배치 처리로 충분한 작업” 정도
  * 구체적인 ms/초 단위 수치는 설계/운영 문서에서 다룸

#### 9. 승인 기준 (Acceptance Criteria)

* **테스트 가능하고 검증 가능한 기준만** 기술합니다.
* 각 AC는 “입력/상황 → 기대 결과” 형태의 **블랙박스 테스트**로 표현합니다.

  * 내부 메트릭/로그/테이블 등을 기준으로 삼지 않습니다.
* 예시:

  * “Trial이 만료된 사용자는 유료 기능 호출 시 항상 403을 받는다.”
  * “구독이 Grace 상태일 때, 사용자 대시보드에는 ‘결제 문제로 곧 종료 예정’ 메시지가 표시된다.”
* 각 AC는 **Pass/Fail**로 명확히 판단 가능해야 합니다.

---

## 6. 작성 스타일

* 간결하고 명확한 문장 사용

  * 가능하면 능동태 사용, 책임 주체를 분명히 표현
* 외부/신규 인원을 기준 독자로 상정

  * 내부 팀에서만 아는 줄임말, 코드명 사용 금지
* 용어 일관성

  * 새로운 용어를 도입할 때는 반드시 “용어” 섹션에 정의 후 사용
* UI 텍스트/버튼명:

  * 실제 노출 문자열은 `"..."`로 감싸서 구분
* 경로/라우트:

  * 필요 시 개념 이름으로만 설명 (예: “구독 관리 화면”)
  * 실제 URL/라우트는 Spec에 포함하지 않음
* 리스트는 7개 이하로 그룹화

  * 복잡한 절차는 번호 매기기 사용

---

## 7. 다이어그램 규칙

* 모든 다이어그램은 **Mermaid**만 사용

  * 플로우차트, 시퀀스 다이어그램, 상태도 권장
* 라벨링

  * 요소/화살표 라벨은 한국어 사용
  * API/라우트 이름이 꼭 필요할 경우, 개념적으로만 표기
* 복잡도 관리

  * 하나의 다이어그램은 한 화면 안에 들어오도록 구성
  * 너무 복잡한 경우 다이어그램을 기능/시나리오 단위로 분할

---

## 8. 교차참조 규칙

Spec 문서는 그 자체로 읽히는 완결 문서여야 하지만,
필요 시 다음과 같이 다른 문서를 참조할 수 있습니다.

* **관련 Spec**

  * `docs/specs/` 내 다른 스펙 문서 (상대 경로 사용)
* **API 문서**

  * 별도 관리되는 API 명세 문서 링크만 제공 (스키마를 복사하지 않음)
* **설계/운영 문서**

  * 아키텍처, DB 스키마, 로그/메트릭 설계, 성능 튜닝 등 구현·운영 세부사항 문서 링크 제공

> **중요**
> 링크만 제공하고, 참조 문서 내용을 이 스펙에 복사/요약하지 않습니다.
> 각 문서는 자신의 책임 범위만 유지합니다.

---

## 9. 안티패턴 (절대 금지)

### 9.1 미완성 문서 형태

* ❌ `TODO`, `미정`, `TBD`, `추후 결정` 등
* ❌ 변경 이력, 수정 날짜, 버전 정보
* ❌ 일부 섹션만 작성된 문서 (빈 섹션, “추가 예정” 문구)
* ❌ 임시 문서, Draft 상태로 장기간 방치

### 9.2 API/구현/운영 세부사항

* ❌ DB 테이블/컬럼/인덱스/뷰 이름
* ❌ 클래스/서비스/유즈케이스/함수 이름
* ❌ HTTP 엔드포인트, 메서드, 상태 코드, 요청/응답 스키마
* ❌ 로그/메트릭 이름 및 필드 정의, 대시보드 구성
* ❌ 타임아웃/Retry/Backoff 구체 숫자, p95/p99 수치
* ❌ 특정 라이브러리/프레임워크 설정/옵션/사용법

### 9.3 불완전하거나 맥락 없는 설명

* ❌ “이번 변경으로 X가 추가됨”처럼 **변경점만 나열**하고 전체 맥락 누락
* ❌ 플로우/상태/정책/AC 중 일부만 작성하고 나머지 비워두기
* ❌ 예외 처리나 에러 케이스 생략

---

## 10. 셀프 체크리스트

스펙 작성/리뷰 시 아래 질문에 모두 “예”라고 답할 수 있어야 합니다.

1. 이 문서는 코드를 전혀 보지 않은 외부 엔지니어/PM이 읽어도 이해할 수 있는가?
2. 도메인 엔티티/상태/플로우/정책만 보고도 주요 설계 리스크를 토론할 수 있는가?
3. 프로세스 관점에서 “어디가 병목/리스크 후보인지”를 코드 없이도 추론할 수 있는가?
4. API 스키마, DB 스키마, 함수/클래스 이름, 로그/메트릭 이름이 문서에 등장하지 않는가?
5. Acceptance Criteria가 모두 **블랙박스 테스트** 형태로 작성되어 있는가?

모두 “예”라면, 그 문서는 **진정한 사양서(Spec)**입니다.

```